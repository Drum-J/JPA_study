### 영속성 컨텍스트의 특징
- 영속성 컨텍스트와 식별자 값
  - 엔티티를 식별자 값(@Id 로 테이블의 기본 키와 매핑한 값)으로 구분, 따라서 영속 상태는 식별자 값이 반드시 있어야 한다.

- 영속성 컨텍스트와 데이터베이스 저장
  - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영하는데 이를 `플러시(flush)` 라 한다.

- 영속성 켄텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

---

### 1차 캐시
영속성 컨텍스트는 내부에 캐시를 가지고 있다. 이것을 1차 캐시라 부르고, 영속 상태의 엔티티는 모두 이곳에 저장된다.

```java
//엔티티를 생성 (비영속)
Member member = new Member();
member.setId("member1"); //1차 캐시의 key
member.setName("승호");

//엔티티를 영속
em.persist(member); //1차 캐시의 value, 엔티티 인스턴스가 값으로 들어간다.
```

>아직 DB에 저장되지 않았다는 것을 기억하자.

1차 캐시의 키는 식별자 값이다`(@Id)`. 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 DB 기본 키 값이다.

```java
//엔티티를 조회해보자
Member member = em.find(Member.class, "member1");
```
find() 메소드의 첫 번째 파라미터는 엔티티 클래스이고, 두 번째는 조회할 엔티티의 식별자 값이다.

>em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고, 없으면 DB에서 조회한다.

### 영속 엔티티의 동일성 보장

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // 과연 true 일까?
```

해당 코드를 보면 `em.find()`의 파라미터가 같은 것을 볼 수 있다.
<br>이처럼 반복해서 호출해도 영속성 컨텍스트는 `1차 캐시에 있는 같은 엔티티 인스턴스`를 반환한다. 따라서 둘은 같은 인스턴스이고 결과 또한 true가 된다.

>영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.

---

### 엔티티 등록, 쓰기 지연
EM은 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소에 SQL을 차곡차곡 모아둔다.
<br>그리고 트랜잭션을 `커밋`할 때 모아둔 쿼리를 DB에 보내는데 이것을 `트랜잭션을 지원하는 쓰기 지연` 이라 한다.

트랜잭션을 커밋하면 EM은 우선 영속성 컨텍스트를 `플러시` 한다.<br>
플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화 하는 작업인데 이때 등록,수정,삭제한 엔티티를 DB에 반영한다.

이렇게 변경 내용을 DB에 동기화 하고 난 이후 실제 DB 트랜잭션을 커밋한다.

---

### 변경 감지 
JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다.<br>
???? 아니 어떻게 변경만 한다고 그게 가능하지..? `변경 감지` 기능이 다 알아서 해준다.

JPA는 엔티티를 영속성 컨텍스트에 보관할 때, `최초 상태를 복사`해서 저장해두는데 이것을 `스냅샷`이라 한다.<br>
`플러시 시점`에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다고 한다.

>변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
