### 스프링 컨테이너의 기본 전략
스프링 컨테이너는 `트랜잭션 범위의 영속성 컨텍스트` 전략을 기본으로 사용한다.<br>
트랜잭션과 영속성 컨텍스트의 범위가 같다는 뜻으로 좀 더 풀어서 말하면 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다는 뜻이다.

![image](https://github.com/Drum-J/JPA_study/assets/102205699/cdc0a5ae-3489-496c-b44a-4f2a94af8cff)

이 그림을 보면 영속성 컨텍스트 생존 범위와 트랜잭션 범위가 Service - Repository 에 걸쳐져 있는 걸 볼 수 있다.

보통 서비스 계층에 `@Transactional`을 사용하기 때문!<br>
이 어노테이션이 있으면 호출한 메소드를 실행하기 직전에 스프링의 `트랜잭션 AOP`가 먼저 동작한다.

![image](https://github.com/Drum-J/JPA_study/assets/102205699/0d90f4fa-2638-4252-bc97-9063eb33e990)

이 그림을 간단하게 살펴보자.

HelloController 에서 HelloService의 메소드를 호출하면 스프링 트랜잭션 AOP가 먼저 작동하면서 트랜잭션을 시작한다.<br>
그리고 영속성 컨텍스트의 관리 안에서 엔티티가 사용(조회,등록 등등) 되고 HelloService와 HelloRepository의 모든 작업이 끝나면<br>
작업 당한(?) 엔티티가 HelloController에 반환되는데, 이때 엔티티는 `준영속 상태`가 된다. 서비스 메소드가 끝나면서 트랜잭션과 영속성 컨텍스트가 종료되었기 때문!!


---

### 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.
![image](https://github.com/Drum-J/JPA_study/assets/102205699/b8a098e3-5dce-4a49-bb95-5571e08dbea8)
다양한 위치에서 엔티티 매니저를 주입받아 사용해도 트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용한다.

---

### 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.

같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.
![image](https://github.com/Drum-J/JPA_study/assets/102205699/5a0fb56f-b7fc-48b0-8b16-01b4486d9c96)


---

스프링이나 J2EE 컨테이너의 가장 큰 장점은 트랜잭션과 복잡한 멀티 스레드 상황을 컨테이너가 처리해준다는 점!
